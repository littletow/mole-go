name: Release

# Create one GitHub Release (find or create draft) and let matrix build jobs upload
# their platform packages to that same release (方案 A)。
# 特性：
# - 如果该 tag 已存在 release，则复用它（无论 draft 还是已发布），并返回 upload_url。
# - 如果不存在，则创建一个 draft release（便于你在网页中编辑标题/内容后再 Publish）。
# - 上传前会尝试删除同名的已存在 asset（避免 Validation Failed: already_exists）。
on:
  push:
    tags:
      - "v*" # 推送 v1.0.0 这种标签时触发
  workflow_dispatch:

permissions:
  contents: write

jobs:
  create-release:
    name: Find or create release (draft)
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.find_or_create_release.outputs.upload_url }}
      release_id: ${{ steps.find_or_create_release.outputs.release_id }}
      existing: ${{ steps.find_or_create_release.outputs.existing }}
      draft: ${{ steps.find_or_create_release.outputs.draft }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find or create release (draft) using GitHub API
        id: find_or_create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // core, github, context are injected by actions/github-script
            const tag = process.env.TAG_NAME;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            try {
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner,
                repo,
                tag
              });
              core.info(`Found existing release id=${release.id}, draft=${release.draft}`);
              core.setOutput('upload_url', release.upload_url);
              core.setOutput('release_id', String(release.id));
              core.setOutput('existing', 'true');
              core.setOutput('draft', release.draft ? 'true' : 'false');
            } catch (err) {
              if (err.status === 404) {
                core.info(`No release for tag ${tag}, creating draft release...`);
                const { data: newRelease } = await github.rest.repos.createRelease({
                  owner,
                  repo,
                  tag_name: tag,
                  name: `Release ${tag}`,
                  body: '',       // 留空，方便你在网页上填写 release notes
                  draft: true,    // 创建为草稿，便于手动编辑后再发布
                  prerelease: false
                });
                core.setOutput('upload_url', newRelease.upload_url);
                core.setOutput('release_id', String(newRelease.id));
                core.setOutput('existing', 'false');
                core.setOutput('draft', newRelease.draft ? 'true' : 'false');
              } else {
                throw err;
              }
            }
        env:
          TAG_NAME: ${{ github.ref_name }}

  build:
    name: Build and upload per-platform
    needs: create-release
    strategy:
      matrix:
        include:
          - {
              os: windows-latest,
              platform: "windows/amd64",
              pkg_ext: ".zip",
              suffix: ".exe",
            }
          - {
              os: macos-latest,
              platform: "darwin/amd64",
              pkg_ext: ".zip",
              suffix: "",
            }
          - {
              os: macos-latest,
              platform: "darwin/arm64",
              pkg_ext: ".zip",
              suffix: "",
            }
          - {
              os: ubuntu-latest,
              platform: "linux/amd64",
              pkg_ext: ".tar.gz",
              suffix: "",
            }
    runs-on: ${{ matrix.os }}
    env:
      # 固定项目名为 mole（你要求的）
      PROJECT_NAME: mole
      VERSION: ${{ github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip pkg-config libgtk-3-dev
          sudo apt-get install -y libwebkit2gtk-4.1-dev || sudo apt-get install -y libwebkit2gtk-4.0-dev
          sudo apt-get install -y libayatana-appindicator3-dev

      - name: Install Wails 3
        run: go install github.com/wailsapp/wails/v3/cmd/wails3@latest

      - name: Prepare bin resources
        shell: bash
        run: |
          mkdir -p resources/bin
          unzip -o resources/bin.zip -d resources/bin/ || true

      - name: Build App (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        run: |
          set -e
          echo "Building for ${{ matrix.platform }}..."
          wails3 build
          echo "=== bin content ==="
          ls -R bin || true

      - name: Build App (non-Windows)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          set -e
          GOPATH_BIN=$(go env GOPATH)/bin
          export PATH=$PATH:$GOPATH_BIN
          export CGO_ENABLED=1
          echo "Building for ${{ matrix.platform }} (CGO_ENABLED=$CGO_ENABLED)..."
          wails3 build
          echo "=== bin content ==="
          ls -R bin || true

      - name: Detect output and create package (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $SUFFIX = '${{ matrix.suffix }}'
          $PKG_EXT = '${{ matrix.pkg_ext }}'
          $SAFE = '${{ matrix.platform }}' -replace '/','_'
          $PROJECT_NAME = $env:PROJECT_NAME
          $VERSION = $env:VERSION
          $PKG_NAME = "${PROJECT_NAME}_${SAFE}_${VERSION}${PKG_EXT}"
          $PKG_PATH = Join-Path $PWD $PKG_NAME

          Write-Host "PROJECT_NAME=$PROJECT_NAME"
          Write-Host "VERSION=$VERSION"
          Write-Host "Looking for build outputs under ./bin matching *$SUFFIX ..."

          $BIN = Get-ChildItem -Path 'bin' -File -Filter "*$SUFFIX" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $BIN) {
            Write-Host "No build output found in bin/; listing contents for debug:"
            Get-ChildItem -Path bin -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          Write-Host "Found binary file: $($BIN.FullName)"
          Compress-Archive -Path $BIN.FullName -DestinationPath $PKG_PATH -Force

          "PKG_NAME=$PKG_NAME" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "PKG_PATH=$PKG_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Detect output and create package (non-Windows)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          set -e
          SUFFIX="${{ matrix.suffix }}"
          PKG_EXT="${{ matrix.pkg_ext }}"
          SAFE_NAME=$(echo "${{ matrix.platform }}" | tr '/' '_')
          PKG_NAME="${PROJECT_NAME}_${SAFE_NAME}_${VERSION}${PKG_EXT}"
          PKG_PATH="${PWD}/${PKG_NAME}"

          echo "PROJECT_NAME=${PROJECT_NAME}"
          echo "VERSION=${VERSION}"
          echo "Looking for build outputs under ./bin ..."

          BIN_FILE=$(find bin -maxdepth 1 -type f -name "*${SUFFIX}" | head -n 1 || true)

          if [ -z "$BIN_FILE" ]; then
            APP_DIR=$(find bin -maxdepth 1 -type d -name "*${PROJECT_NAME}*.app" -print -quit || true)
            if [ -n "$APP_DIR" ]; then
              echo "Found app bundle: $APP_DIR"
              zip -r "$PKG_PATH" "$APP_DIR"
            else
              ANY_BIN=$(find bin -maxdepth 1 -type f -print -quit || true)
              if [ -n "$ANY_BIN" ]; then
                BIN_FILE="$ANY_BIN"
                echo "Using found binary: $BIN_FILE"
                if [ "$PKG_EXT" = ".zip" ]; then
                  zip -j "$PKG_PATH" "$BIN_FILE"
                else
                  mkdir -p "${PROJECT_NAME}"
                  cp "$BIN_FILE" "${PROJECT_NAME}/"
                  tar -czvf "$PKG_PATH" "${PROJECT_NAME}"
                  rm -rf "${PROJECT_NAME}"
                fi
              else
                echo "No build output found in bin/ (expected binary or .app). Listing bin:"
                ls -R bin || true
                exit 1
              fi
            fi
          else
            echo "Found binary file: $BIN_FILE"
            if [ "$PKG_EXT" = ".zip" ]; then
              zip -j "$PKG_PATH" "$BIN_FILE"
            else
              mkdir -p "${PROJECT_NAME}"
              cp "$BIN_FILE" "${PROJECT_NAME}/"
              tar -czvf "$PKG_PATH" "${PROJECT_NAME}"
              rm -rf "${PROJECT_NAME}"
            fi
          fi

          echo "PKG_NAME=${PKG_NAME}" >> $GITHUB_ENV
          echo "PKG_PATH=${PKG_PATH}" >> $GITHUB_ENV

      - name: Show package (Windows) (debug)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Write-Host "Package created: $env:PKG_NAME at $env:PKG_PATH"
          if (Test-Path $env:PKG_PATH) {
            Get-Item $env:PKG_PATH | Format-List Name,Length,FullName
          } else {
            Write-Host "Package not found at $env:PKG_PATH"
            Write-Host "Listing bin/ for debug:"
            Get-ChildItem -Path bin -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

      - name: Show package (non-Windows) (debug)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          echo "Package created: $PKG_NAME at $PKG_PATH"
          ls -lh "$PKG_PATH" || true

      - name: Delete same-named release asset if exists
        id: delete_asset
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // github, context injected
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const release_id = parseInt(process.env.RELEASE_ID || '0', 10);
            const assetName = process.env.ASSET_NAME;
            if (!release_id || !assetName) {
              core.info('No release_id or asset name provided, skipping delete step.');
              core.setOutput('deleted', 'false');
              return;
            }
            core.info(`Looking for existing asset "${assetName}" in release ${release_id}...`);
            const assets = await github.rest.repos.listReleaseAssets({
              owner, repo, release_id
            });
            const found = assets.data.find(a => a.name === assetName);
            if (found) {
              core.info(`Found existing asset id=${found.id}, deleting...`);
              await github.rest.repos.deleteReleaseAsset({
                owner, repo, asset_id: found.id
              });
              core.setOutput('deleted', 'true');
            } else {
              core.info('No existing asset with that name.');
              core.setOutput('deleted', 'false');
            }
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          ASSET_NAME: ${{ env.PKG_NAME }}

      - name: Upload release asset (zip)
        if: matrix.pkg_ext == '.zip'
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ env.PKG_PATH }}
          asset_name: ${{ env.PKG_NAME }}
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release asset (tar.gz)
        if: matrix.pkg_ext == '.tar.gz'
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ env.PKG_PATH }}
          asset_name: ${{ env.PKG_NAME }}
          asset_content_type: application/gzip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
